---
title: TLS Certificates
description: How to configure TLS certificates for secure connections
sidebar_label: TLS Certificates
hide_table_of_contents: false
toc_min_heading_level: 2
toc_max_heading_level: 3
---

import DistributionCard from '@site/src/components/DistributionCard/DistributionCard.js';
import distributions from '@site/data/distributions.json';
import styles from '@site/src/components/DistributionCard/DistributionCard.module.css';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Chips from "/src/components/Chips/Chips";

export const DistributionCardWrapper = ({ type }) => {

  const logos = distributions.reduce((acc, { slug, logo }) => {
    acc[slug] = logo;
    return acc;
  }, {});

  const data = {
    auto: [
      {
        key: 'aws',
        logo: logos['aws-ami'],
        name: 'AWS',
        links: {
          ce: {
            slug: 'ce/aws-auto',
            label: 'CE',
          },
          pro: {
            slug: 'pro/aws-auto',
            label: 'PRO',
          }
        }
      },
      {
        key: 'debian',
        logo: logos['debian'],
        name: 'Debian/Ubuntu',
        links: {
          ce: {
            slug: 'ce/debian-auto',
            label: 'CE',
          },
          pro: {
            slug: 'pro/debian-auto',
            label: 'PRO',
          }
        }
      },
      {
        key: 'digital-ocean',
        logo: logos['digital-ocean'],
        name: 'Digital Ocean',
        links: {
          ce: {
            slug: 'ce/digital-ocean-auto',
            label: 'CE',
          },
        }
      },
      {
        key: 'docker',
        logo: logos['docker'],
        name: 'Docker',
        links: {
          ce: {
            slug: 'ce/docker-auto',
            label: 'CE',
          },
          pro: {
            slug: 'pro/docker-auto',
            label: 'PRO',
          }
        }
      },
      {
        key: 'ova',
        logo: logos['virtual-appliance'],
        name: 'OVA',
        links: {
          pro: {
            slug: 'pro/ova-auto',
            label: 'PRO',
          }
        }
      }
    ],
    manual: [
      {
        key: 'debian',
        logo: logos['debian'],
        name: 'Debian/Ubuntu',
        links: {
          ce: {
            slug: 'ce/debian-manual',
            label: 'CE',
          },
          pro: {
            slug: 'pro/debian-manual',
            label: 'PRO',
          }
        }
      },
      {
        key: 'docker',
        logo: logos['docker'],
        name: 'Docker',
        links: {
          ce: {
            slug: 'ce/docker-manual',
            label: 'CE',
          },
          pro: {
            slug: 'pro/docker-manual',
            label: 'PRO',
          }
        }
      },
      {
        key: 'rpm',
        logo: logos['virtual-appliance'],
        name: 'RPM',
        links: {
          ce: {
            slug: 'ce/rpm-manual',
            label: 'CE',
          },
          pro: {
            slug: 'pro/rpm-manual',
            label: 'PRO',
          }
        }
      }
    ]
  }

  return (
    <div className={styles.grid}>
      {data[type].map((distribution) => {
        return (
          <DistributionCard
            key={distribution.key}
            logo={distribution.logo}
            name={distribution.name}
            links={distribution.links}
          />
        );
      })}
    </div>
  );
};

<div style={{display: "flex", gap: "1rem"}}>
  <Chips link="https://www.passbolt.com/ce/docker" isUnderMainTitle={true}>CE</Chips>
  <Chips link="https://www.passbolt.com/pricing/pro" isUnderMainTitle={true}>Pro</Chips>
</div>

## Introduction to Certificate Authorities (CAs) and Trust

A **Certificate Authority (CA)** is an entity that issues **TLS (SSL) certificates** to validate the identity of websites, servers, or organisations. Major CAs, such as **DigiCert**, **GlobalSign**, **Let's Encrypt**, and **Entrust**, are trusted by browsers and operating systems to sign **Certificate Signing Requests (CSRs)**. These CAs verify the identity of the requester and sign the `CSR` to issue a certificate, which can then be used to secure communications.

:::note
SSL was originally developed by Netscape and became TLS in 1999 when the IETF standardised it as an open protocol. Although SSL has been obsolete for over 25 years, the terms SSL and TLS are still used interchangeably. In our documentation, we use TLS (SSL) to make it easier to search, and some environment variables still include “SSL” for compatibility. Tools like OpenSSL also retain the SSL name, even though they implement TLS.
:::

The trust in a certificate issued by these CAs comes from their **root certificate**, which is included in the **root certificate stores** maintained by organisations like **Mozilla** (Firefox, Debian, Red Hat, openSUSE, Ubuntu, through `ca-certificates`), **Google** (Chrome, Android, Brave, Opera, Vivaldi, Samsung Internet, Yandex), **Apple** (Safari, macOS, iOS), and **Microsoft** (Edge, Windows). These vendors validate and include CAs in their root stores, ensuring that any certificate signed by a trusted CA will be accepted across platforms. However, **occasionally, CAs are removed from these stores** if they fail to meet the required security standards or if they are compromised. When this happens, certificates issued by that CA may no longer be trusted, and affected organisations must replace those certificates.

**Cross-recognition** allows a CA that is included in one root certificate store to apply for recognition in other vendors' stores. This means that once a CA is trusted by one vendor, such as **Mozilla**, **Google**, or **Microsoft**, the CA can request inclusion in other root stores. This helps ensure that certificates issued by that CA are trusted across all major platforms and browsers, making them widely accepted across the internet.

**Let's Encrypt** is a widely used free, automated, and open CA that issues **TLS (SSL) certificates**. **Let's Encrypt**'s root certificate, **ISRG Root X1**, is included in the root stores of major platforms. It also uses intermediate certificates to create a **chain of trust** for validating issued certificates. For more information on **Let's Encrypt's root and intermediate certificates**, you can visit their official page: [Let's Encrypt Certificates](https://letsencrypt.org/certificates/).

### Public vs. Private CAs

While **public CAs** are globally recognised and trusted across the internet, organisations, including **enterprise customers**, may set up their own **private CAs** to issue certificates for **internal use**. This is particularly common in large organisations with complex security and compliance needs, where a **Private Key Infrastructure (PKI)** is set up to manage certificates internally.

#### Private CAs and PKI for Enterprise Use:
In an enterprise setting, a **private CA** is often used to issue certificates within the organisation's own network. Certificates issued by a private CA are **not automatically trusted** by browsers or operating systems, as private CAs are not included in public root stores. To trust certificates issued by a private CA, the **root certificate** of the private CA must be **manually added** to the **trust stores** of the systems that need to validate those certificates. This allows secure communication and internal authentication for various services, including **internal web servers, VPNs, secure email**, and other critical systems.

### The Changing Lifespan of TLS Certificates: A Call for Automation

The lifespan of **TLS certificates** is being progressively reduced to increase security and ensure that certificates are refreshed more frequently. This change will significantly impact certificate management for all network connected computers on the internet.

Here is the new **TLS certificate lifespan schedule** set by vendors in Ballot SC-081v3:

- **Now until March 15, 2026**: The maximum certificate lifetime is **398 days**.
- **From March 15, 2026**: The maximum certificate lifetime will be **200 days**.
- **From March 15, 2027**: The maximum certificate lifetime will be **100 days**.
- **From March 15, 2029**: The maximum certificate lifetime will be reduced to **47 days**.

This reduction in certificate lifespan means that **manual certificate management** will soon be unsustainable. With certificates expiring more frequently, **automated certificate management** becomes essential. Organisations need to implement **automatic certificate renewal** and deployment systems to avoid disruptions due to expired certificates.

### Why This Matters for passbolt Customers

For **passbolt** users, particularly **enterprise organisations**, this change means that **automating certificate deployment and renewal** is no longer optional. Manual certificate management will lead to **outages** and **security vulnerabilities** as certificates expire. Organisations will need to ensure that their systems are capable of **automatically renewing** and **deploying certificates** without manual intervention.

As TLS certificates continue to evolve, **automation** will become an essential part of keeping systems secure and operational. passbolt's ability to integrate with modern certificate management systems will help organisations adapt to these changes without disruption.

### Self-Signed Certificates
A self-signed certificate is created and signed by the same system that uses it, without involving a public CA. While it still provides encryption, it won’t be automatically trusted by browsers, operating systems, or passbolt clients.  
- **Typical use cases:** local development, staging servers, or private/internal deployments.  
- **Trust requirements:** the certificate (or its issuing root) must be manually installed in the trust store of each client system or browser to avoid TLS errors when accessing passbolt.  
- **Security**: Self-signed certificates are generated with the same cryptography as certificates created by a CA. They do however come with challenges when deployed in production deployments. Revocation or reissuing can only be achieved manually by a system administrator.

### Certificate Bundles
A certificate bundle contains the full certificate chain needed for a client to verify the server’s identity — usually the server certificate, any intermediate CA certificates, and the root CA certificate.  
- passbolt relies on a complete and correct chain so that browsers and API clients can validate the TLS connection.  
- Public CAs like Let’s Encrypt provide these bundles for download, and your web server must be configured to serve the full chain.  
- If you use an internal CA, you will need to distribute and trust the root certificate across all systems that connect to passbolt.  

### Installing and Using Self-Signed Certificates and Certificate Bundles in passbolt

1. **Installing Self-Signed Certificates**:
   - **Operating System**: On **Linux** (e.g., **Ubuntu**, **Debian**, **Red Hat**), **self-signed certificates** need to be manually installed into the **system's trust store** (via commands like `update-ca-certificates` or `trust anchor` for Red Hat-based systems). This allows **passbolt** or other services to trust the certificate for secure communication.
   - **passbolt**: If **passbolt** is configured to use **self-signed certificates** or **internal certificates** (such as in a private instance), the certificate must be added to the **trusted certificates** list in the **passbolt** application. This typically involves placing the certificate bundle in the appropriate directory or referencing it in the passbolt configuration file (`config/passbolt.php`), ensuring the application can establish secure connections.

2. **Using Certificate Bundles**:
   - **Operating System**: Certificate bundles can be installed on the system in the appropriate location to establish trust. On **Ubuntu**, for example, you can place the bundle in `/usr/local/share/ca-certificates/` and run `update-ca-certificates`.
   - **passbolt**: If you are using a certificate bundle in **passbolt**, you'll need to ensure the server and client systems can access the appropriate chain. passbolt's configuration may need to reference the complete **certificate chain** (root + intermediate certificates) to ensure full trust and avoid SSL/TLS errors.

### CA and Trust Overview:

| **Type of CA**       | **Root Certificate Authority**                                                                 | **Trust Model**                                     | **Trust Scope**                     | **Trust Store Users**                          |
|----------------------|-----------------------------------------------------------------------------------------------|----------------------------------------------------|-------------------------------------|-------------------------------------------------|
| **Public CA**        | **DigiCert**, **GlobalSign**, **Let's Encrypt**, **Entrust**, **Mozilla** (Firefox, Debian, Red Hat, openSUSE, Ubuntu, through `ca-certificates`), **Google** (Chrome, Android, Brave, Opera, Vivaldi, Samsung Internet, Yandex), **Apple** (Safari, macOS, iOS), **Microsoft** (Edge, Windows) | Automatically trusted by browsers and OS systems.   | Global (trusted by major browsers and OSs). | **Mozilla** (Firefox, Debian, Red Hat, openSUSE, Ubuntu, through `ca-certificates`), **Google** (Chrome, Android, Brave, Opera, Vivaldi, Samsung Internet, Yandex), **Apple** (Safari, macOS, iOS), **Microsoft** (Edge, Windows) |
| **Private CA**       | Internal organisation or enterprise.                                                         | Trusted within specific organisations or networks. | Limited to the organisation (root certificate must be manually installed). | **Custom trust configuration required** |
| **Self-Signed Cert** | The entity itself (no external CA involved).                                                  | Not trusted by default, trust must be manually added. | Local or isolated systems.           | **Custom trust configuration required** |

This table summarises the different types of **Certificate Authorities (CAs)**, their associated trust models, and who uses the trusted root certificate stores, from widely recognised public CAs to private, internal CAs and self-signed certificates used for isolated purposes.

## Technical Deep Dive: TLS Certificate Structure and Cryptography

### X.509 Certificate Format

TLS certificates follow the **X.509 standard** (RFC 5280), which defines the structure and encoding of public key certificates. An X.509 certificate contains several critical components:

#### Certificate Structure
```
Certificate
├── Version (v3)
├── Serial Number (unique identifier)
├── Signature Algorithm ID (e.g., sha256WithRSAEncryption)
├── Issuer Name (CA information)
├── Validity Period
│   ├── Not Before
│   └── Not After
├── Subject Name (entity information)
├── Subject Public Key Info
│   ├── Public Key Algorithm (RSA, ECDSA, Ed25519)
│   └── Subject Public Key
├── Issuer Unique Identifier (optional)
├── Subject Unique Identifier (optional)
├── Extensions (critical and non-critical)
│   ├── Subject Alternative Names (SAN)
│   ├── Key Usage
│   ├── Extended Key Usage
│   ├── Basic Constraints
│   ├── Authority Key Identifier
│   ├── Subject Key Identifier
│   └── Certificate Policies
└── Certificate Signature
    ├── Signature Algorithm
    └── Signature Value
```

### Cryptographic Algorithms and Key Sizes

#### RSA Certificates
- **Key Generation**: Uses the RSA algorithm based on the difficulty of factoring large prime numbers
- **Minimum Key Size**: 2048 bits (required by all major browsers)
- **Recommended Key Size**: 4096 bits for long-term certificates
- **Signature Algorithms**: SHA-256, SHA-384, SHA-512 with RSA
- **Performance**: Slower than ECDSA for signing operations

#### ECDSA Certificates
- **Key Generation**: Based on elliptic curve cryptography
- **Supported Curves**: P-256 (secp256r1), P-384 (secp384r1), P-521 (secp521r1)
- **Key Sizes**: 256, 384, or 521 bits (equivalent to 3072, 7680, or 15360-bit RSA)
- **Signature Algorithms**: ECDSA with SHA-256, SHA-384, SHA-512
- **Performance**: Faster signing and verification than RSA

#### Ed25519 Certificates
- **Key Generation**: Based on Edwards-curve Digital Signature Algorithm
- **Key Size**: 256 bits (equivalent to ~3072-bit RSA)
- **Signature Algorithm**: Ed25519
- **Performance**: Fastest signing and verification
- **Security**: High resistance to side-channel attacks

### Certificate Extensions and Constraints

#### Critical Extensions
- **Basic Constraints**: Defines if the certificate can be used as a CA
  ```
  Basic Constraints: critical
      CA: TRUE
      Path Length Constraint: 0
  ```
- **Key Usage**: Specifies allowed cryptographic operations
  ```
  Key Usage: critical
      Digital Signature
      Key Encipherment
  ```

#### Non-Critical Extensions
- **Subject Alternative Names (SAN)**: Lists valid domain names
  ```
  X509v3 Subject Alternative Name:
      DNS:example.com, DNS:www.example.com, DNS:*.example.com
  ```
- **Extended Key Usage**: Defines specific purposes
  ```
  X509v3 Extended Key Usage:
      TLS Web Server Authentication
      TLS Web Client Authentication
  ```

### Certificate Chain Validation Process

#### Chain of Trust Verification
1. **Certificate Parsing**: Extract and validate certificate structure
2. **Signature Verification**: Verify certificate signature using issuer's public key
3. **Validity Period Check**: Ensure current time is within certificate validity
4. **Revocation Check**: Verify certificate hasn't been revoked (CRL/OCSP)
5. **Policy Validation**: Check certificate policies and constraints
6. **Name Validation**: Verify subject name matches expected identity

#### Certificate Revocation
- **Certificate Revocation Lists (CRL)**: Periodic lists of revoked certificates
- **Online Certificate Status Protocol (OCSP)**: Real-time revocation checking
- **OCSP Stapling**: Server provides OCSP response with certificate
- **Must-Staple**: Certificate extension requiring OCSP stapling

### TLS Handshake and Certificate Usage

#### TLS 1.3 Certificate Exchange
```
ClientHello
    ↓
ServerHello + Certificate + CertificateVerify
    ↓
Client Certificate (if requested)
    ↓
Finished
```

#### Certificate Verification in TLS
1. **Server Certificate**: Client validates server's certificate chain
2. **Certificate Request**: Server may request client certificate (mutual TLS)
3. **Certificate Verify**: Proof of possession of private key
4. **Key Exchange**: Ephemeral keys for session encryption

### Security Considerations

#### Certificate Transparency
- **CT Logs**: Public, append-only logs of all issued certificates
- **SCT (Signed Certificate Timestamp)**: Proof of inclusion in CT logs
- **Monitoring**: Detection of unauthorized certificate issuance

#### Certificate Pinning
- **HPKP (HTTP Public Key Pinning)**: Deprecated, replaced by Expect-CT
- **Expect-CT**: Header indicating CT compliance expectation
- **Certificate Authority Authorization (CAA)**: DNS records restricting CA issuance

#### Quantum Resistance
- **Post-Quantum Cryptography**: Algorithms resistant to quantum attacks
- **Hybrid Schemes**: Combining classical and quantum-resistant algorithms
- **Migration Planning**: Preparing for quantum computing threats

## Related Documentation

- [HTTPS Configuration](/hosting/configure/https/): Complete HTTPS setup guide
- [Firewall Rules](/hosting/configure/firewall-rules): Required network configuration
- [SSL/TLS Troubleshooting](/hosting/troubleshooting/ssl-tls): Common issues and solutions
- [Environment Reference](/hosting/configure/environment-reference): TLS-related environment variables 